/*
 * SENTINEL IMMUNE â€” Production Exploit Manager
 * 
 * Secure exploit storage with real AES-256-GCM encryption.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <pthread.h>

#include <openssl/evp.h>
#include <openssl/rand.h>
#include <openssl/sha.h>

#include "../include/hive.h"

#define MAX_EXPLOITS        200
#define MAX_EXPLOIT_SIZE    65536
#define EXPLOIT_MAGIC       0x45585032  /* "EXP2" */
#define AES_KEY_SIZE        32
#define AES_IV_SIZE         12
#define AES_TAG_SIZE        16

/* Exploit categories */
typedef enum {
    EXPLOIT_CAT_RECON = 1,
    EXPLOIT_CAT_ACCESS,
    EXPLOIT_CAT_PRIVESC,
    EXPLOIT_CAT_LATERAL,
    EXPLOIT_CAT_EXFIL,
    EXPLOIT_CAT_PERSIST
} exploit_category_t;

/* Platform targeting */
typedef enum {
    PLATFORM_ANY = 0,
    PLATFORM_LINUX,
    PLATFORM_FREEBSD,
    PLATFORM_DRAGONFLY,
    PLATFORM_WINDOWS,
    PLATFORM_MACOS
} target_platform_t;

/* Exploit metadata */
typedef struct {
    uint32_t            exploit_id;
    char                name[64];
    char                cve[32];
    char                description[256];
    
    exploit_category_t  category;
    target_platform_t   platform;
    
    uint8_t             hash[32];           /* SHA-256 of decrypted payload */
    size_t              payload_size;
    size_t              encrypted_size;
    
    int                 enabled;
    int                 risk_level;         /* 1-5 */
    int                 requires_auth;
    
    time_t              added_at;
    time_t              last_used;
    uint64_t            use_count;
    uint64_t            success_count;
} exploit_meta_t;

/* Encrypted payload container */
typedef struct {
    uint8_t             iv[AES_IV_SIZE];
    uint8_t             tag[AES_TAG_SIZE];
    uint8_t             *ciphertext;
    size_t              ciphertext_size;
} encrypted_payload_t;

/* Exploit entry */
typedef struct {
    exploit_meta_t      meta;
    encrypted_payload_t encrypted;
} exploit_t;

/* Exploit manager context */
typedef struct {
    exploit_t           exploits[MAX_EXPLOITS];
    int                 exploit_count;
    
    pthread_mutex_t     lock;
    pthread_rwlock_t    access_lock;
    
    char                storage_path[256];
    uint8_t             encryption_key[AES_KEY_SIZE];
    int                 key_loaded;
    int                 locked;             /* Require reauth */
    
    /* Audit log */
    FILE                *audit_log;
    
    /* Statistics */
    uint64_t            total_uses;
    uint64_t            total_success;
    uint64_t            auth_failures;
} exploit_mgr_t;

/* Global context */
static exploit_mgr_t g_exploits;

/* ==================== Crypto Helpers ==================== */

static int
aes_gcm_encrypt(const uint8_t *plaintext, size_t pt_len,
                const uint8_t *key, const uint8_t *iv,
                uint8_t *ciphertext, uint8_t *tag)
{
    EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new();
    if (!ctx) return -1;
    
    int len, ct_len = 0;
    
    if (EVP_EncryptInit_ex(ctx, EVP_aes_256_gcm(), NULL, key, iv) != 1)
        goto error;
    
    if (EVP_EncryptUpdate(ctx, ciphertext, &len, plaintext, pt_len) != 1)
        goto error;
    ct_len = len;
    
    if (EVP_EncryptFinal_ex(ctx, ciphertext + len, &len) != 1)
        goto error;
    ct_len += len;
    
    if (EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GCM_GET_TAG, AES_TAG_SIZE, tag) != 1)
        goto error;
    
    EVP_CIPHER_CTX_free(ctx);
    return ct_len;
    
error:
    EVP_CIPHER_CTX_free(ctx);
    return -1;
}

static int
aes_gcm_decrypt(const uint8_t *ciphertext, size_t ct_len,
                const uint8_t *key, const uint8_t *iv,
                const uint8_t *tag, uint8_t *plaintext)
{
    EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new();
    if (!ctx) return -1;
    
    int len, pt_len = 0;
    
    if (EVP_DecryptInit_ex(ctx, EVP_aes_256_gcm(), NULL, key, iv) != 1)
        goto error;
    
    if (EVP_DecryptUpdate(ctx, plaintext, &len, ciphertext, ct_len) != 1)
        goto error;
    pt_len = len;
    
    if (EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GCM_SET_TAG, AES_TAG_SIZE,
                            (void *)tag) != 1)
        goto error;
    
    if (EVP_DecryptFinal_ex(ctx, plaintext + len, &len) != 1) {
        /* Tag verification failed! */
        EVP_CIPHER_CTX_free(ctx);
        return -2;  /* Auth failure */
    }
    pt_len += len;
    
    EVP_CIPHER_CTX_free(ctx);
    return pt_len;
    
error:
    EVP_CIPHER_CTX_free(ctx);
    return -1;
}

static void
compute_sha256(const uint8_t *data, size_t len, uint8_t *hash)
{
    SHA256_CTX ctx;
    SHA256_Init(&ctx);
    SHA256_Update(&ctx, data, len);
    SHA256_Final(hash, &ctx);
}

/* ==================== Audit Logging ==================== */

static void
audit_log(const char *action, uint32_t exploit_id, const char *details)
{
    if (!g_exploits.audit_log) return;
    
    time_t now = time(NULL);
    struct tm *tm = localtime(&now);
    char timestamp[32];
    strftime(timestamp, sizeof(timestamp), "%Y-%m-%d %H:%M:%S", tm);
    
    fprintf(g_exploits.audit_log, "[%s] %s exploit=%u %s\n",
            timestamp, action, exploit_id, details ? details : "");
    fflush(g_exploits.audit_log);
}

/* ==================== Initialization ==================== */

int
exploit_init(const char *storage_path, const uint8_t *key)
{
    memset(&g_exploits, 0, sizeof(exploit_mgr_t));
    
    pthread_mutex_init(&g_exploits.lock, NULL);
    pthread_rwlock_init(&g_exploits.access_lock, NULL);
    
    if (storage_path) {
        strncpy(g_exploits.storage_path, storage_path,
                sizeof(g_exploits.storage_path) - 1);
    } else {
        strcpy(g_exploits.storage_path, "/var/immune/exploits");
    }
    
    if (key) {
        memcpy(g_exploits.encryption_key, key, AES_KEY_SIZE);
        g_exploits.key_loaded = 1;
    } else {
        /* Generate random key (should be from HSM in production) */
        if (RAND_bytes(g_exploits.encryption_key, AES_KEY_SIZE) != 1) {
            fprintf(stderr, "EXPLOIT: Failed to generate encryption key\n");
            return -1;
        }
        g_exploits.key_loaded = 1;
    }
    
    /* Open audit log */
    char audit_path[512];
    snprintf(audit_path, sizeof(audit_path), "%s/exploit_audit.log",
             g_exploits.storage_path);
    g_exploits.audit_log = fopen(audit_path, "a");
    
    /* Load existing exploits */
    exploit_load_all();
    
    audit_log("INIT", 0, "Exploit manager initialized");
    
    printf("EXPLOIT: Manager initialized (%d exploits, key=%s)\n", 
           g_exploits.exploit_count,
           g_exploits.key_loaded ? "loaded" : "NONE");
    
    return 0;
}

void
exploit_shutdown(void)
{
    pthread_rwlock_wrlock(&g_exploits.access_lock);
    
    audit_log("SHUTDOWN", 0, "Exploit manager shutting down");
    
    /* Secure wipe all payloads */
    for (int i = 0; i < g_exploits.exploit_count; i++) {
        if (g_exploits.exploits[i].encrypted.ciphertext) {
            OPENSSL_cleanse(g_exploits.exploits[i].encrypted.ciphertext,
                           g_exploits.exploits[i].encrypted.ciphertext_size);
            free(g_exploits.exploits[i].encrypted.ciphertext);
        }
    }
    
    /* Wipe encryption key */
    OPENSSL_cleanse(g_exploits.encryption_key, AES_KEY_SIZE);
    g_exploits.key_loaded = 0;
    
    if (g_exploits.audit_log) {
        fclose(g_exploits.audit_log);
    }
    
    pthread_rwlock_unlock(&g_exploits.access_lock);
    pthread_rwlock_destroy(&g_exploits.access_lock);
    pthread_mutex_destroy(&g_exploits.lock);
    
    printf("EXPLOIT: Shutdown complete\n");
}

/* ==================== Exploit Management ==================== */

uint32_t
exploit_add(const char *name, const char *cve,
            int category, int platform,
            const uint8_t *payload, size_t payload_size,
            int risk_level, const char *description)
{
    if (!g_exploits.key_loaded) {
        fprintf(stderr, "EXPLOIT: Encryption key not loaded\n");
        return 0;
    }
    
    if (g_exploits.exploit_count >= MAX_EXPLOITS) {
        fprintf(stderr, "EXPLOIT: Maximum exploits reached\n");
        return 0;
    }
    
    if (payload_size > MAX_EXPLOIT_SIZE) {
        fprintf(stderr, "EXPLOIT: Payload too large\n");
        return 0;
    }
    
    pthread_rwlock_wrlock(&g_exploits.access_lock);
    
    uint32_t exploit_id = g_exploits.exploit_count + 1;
    exploit_t *exp = &g_exploits.exploits[g_exploits.exploit_count];
    
    memset(exp, 0, sizeof(exploit_t));
    
    /* Metadata */
    exp->meta.exploit_id = exploit_id;
    exp->meta.category = category;
    exp->meta.platform = platform;
    exp->meta.risk_level = risk_level;
    exp->meta.enabled = 1;
    exp->meta.added_at = time(NULL);
    exp->meta.payload_size = payload_size;
    
    if (name) strncpy(exp->meta.name, name, sizeof(exp->meta.name) - 1);
    if (cve) strncpy(exp->meta.cve, cve, sizeof(exp->meta.cve) - 1);
    if (description) strncpy(exp->meta.description, description,
                             sizeof(exp->meta.description) - 1);
    
    /* Compute hash of plaintext */
    compute_sha256(payload, payload_size, exp->meta.hash);
    
    /* Encrypt payload */
    if (payload && payload_size > 0) {
        /* Generate random IV */
        if (RAND_bytes(exp->encrypted.iv, AES_IV_SIZE) != 1) {
            pthread_rwlock_unlock(&g_exploits.access_lock);
            return 0;
        }
        
        /* Allocate ciphertext buffer */
        exp->encrypted.ciphertext = malloc(payload_size + 16);
        if (!exp->encrypted.ciphertext) {
            pthread_rwlock_unlock(&g_exploits.access_lock);
            return 0;
        }
        
        /* Encrypt */
        int ct_len = aes_gcm_encrypt(payload, payload_size,
                                     g_exploits.encryption_key,
                                     exp->encrypted.iv,
                                     exp->encrypted.ciphertext,
                                     exp->encrypted.tag);
        
        if (ct_len < 0) {
            free(exp->encrypted.ciphertext);
            exp->encrypted.ciphertext = NULL;
            pthread_rwlock_unlock(&g_exploits.access_lock);
            return 0;
        }
        
        exp->encrypted.ciphertext_size = ct_len;
        exp->meta.encrypted_size = ct_len;
    }
    
    g_exploits.exploit_count++;
    
    pthread_rwlock_unlock(&g_exploits.access_lock);
    
    audit_log("ADD", exploit_id, name);
    
    printf("EXPLOIT: Added %s (ID=%u, encrypted=%zu bytes)\n", 
           name, exploit_id, exp->meta.encrypted_size);
    
    return exploit_id;
}

int
exploit_remove(uint32_t exploit_id)
{
    pthread_rwlock_wrlock(&g_exploits.access_lock);
    
    for (int i = 0; i < g_exploits.exploit_count; i++) {
        if (g_exploits.exploits[i].meta.exploit_id == exploit_id) {
            exploit_t *exp = &g_exploits.exploits[i];
            
            /* Secure wipe */
            if (exp->encrypted.ciphertext) {
                OPENSSL_cleanse(exp->encrypted.ciphertext,
                               exp->encrypted.ciphertext_size);
                free(exp->encrypted.ciphertext);
                exp->encrypted.ciphertext = NULL;
            }
            
            exp->meta.enabled = 0;
            
            audit_log("REMOVE", exploit_id, "Exploit removed");
            
            pthread_rwlock_unlock(&g_exploits.access_lock);
            return 0;
        }
    }
    
    pthread_rwlock_unlock(&g_exploits.access_lock);
    return -1;
}

/* ==================== Exploit Access ==================== */

int
exploit_get_payload(uint32_t exploit_id, uint8_t **payload, size_t *size)
{
    if (!g_exploits.key_loaded) {
        g_exploits.auth_failures++;
        return -1;
    }
    
    pthread_rwlock_rdlock(&g_exploits.access_lock);
    
    for (int i = 0; i < g_exploits.exploit_count; i++) {
        if (g_exploits.exploits[i].meta.exploit_id == exploit_id &&
            g_exploits.exploits[i].meta.enabled) {
            
            exploit_t *exp = &g_exploits.exploits[i];
            
            if (!exp->encrypted.ciphertext || 
                exp->encrypted.ciphertext_size == 0) {
                pthread_rwlock_unlock(&g_exploits.access_lock);
                return -1;
            }
            
            /* Allocate output buffer */
            *payload = malloc(exp->meta.payload_size + 16);
            if (!*payload) {
                pthread_rwlock_unlock(&g_exploits.access_lock);
                return -1;
            }
            
            /* Decrypt */
            int pt_len = aes_gcm_decrypt(exp->encrypted.ciphertext,
                                         exp->encrypted.ciphertext_size,
                                         g_exploits.encryption_key,
                                         exp->encrypted.iv,
                                         exp->encrypted.tag,
                                         *payload);
            
            if (pt_len < 0) {
                OPENSSL_cleanse(*payload, exp->meta.payload_size);
                free(*payload);
                *payload = NULL;
                
                if (pt_len == -2) {
                    /* Authentication failure - tampering detected! */
                    audit_log("TAMPER", exploit_id, "Decryption auth failed!");
                    g_exploits.auth_failures++;
                }
                
                pthread_rwlock_unlock(&g_exploits.access_lock);
                return -1;
            }
            
            *size = pt_len;
            
            /* Verify hash */
            uint8_t computed_hash[32];
            compute_sha256(*payload, pt_len, computed_hash);
            
            if (memcmp(computed_hash, exp->meta.hash, 32) != 0) {
                /* Hash mismatch - corruption! */
                audit_log("CORRUPT", exploit_id, "Hash verification failed!");
                OPENSSL_cleanse(*payload, pt_len);
                free(*payload);
                *payload = NULL;
                pthread_rwlock_unlock(&g_exploits.access_lock);
                return -1;
            }
            
            /* Update stats */
            exp->meta.use_count++;
            exp->meta.last_used = time(NULL);
            g_exploits.total_uses++;
            
            audit_log("ACCESS", exploit_id, "Payload decrypted");
            
            pthread_rwlock_unlock(&g_exploits.access_lock);
            return 0;
        }
    }
    
    pthread_rwlock_unlock(&g_exploits.access_lock);
    return -1;
}

void
exploit_release_payload(uint8_t *payload, size_t size)
{
    if (payload) {
        OPENSSL_cleanse(payload, size);
        free(payload);
    }
}

void
exploit_mark_success(uint32_t exploit_id)
{
    pthread_rwlock_wrlock(&g_exploits.access_lock);
    
    for (int i = 0; i < g_exploits.exploit_count; i++) {
        if (g_exploits.exploits[i].meta.exploit_id == exploit_id) {
            g_exploits.exploits[i].meta.success_count++;
            g_exploits.total_success++;
            
            audit_log("SUCCESS", exploit_id, "Exploit execution successful");
            break;
        }
    }
    
    pthread_rwlock_unlock(&g_exploits.access_lock);
}

/* ==================== Persistence ==================== */

int
exploit_save_all(void)
{
    char path[512];
    snprintf(path, sizeof(path), "%s/exploits.db", g_exploits.storage_path);
    
    pthread_rwlock_unlock(&g_exploits.access_lock);
    
    FILE *fp = fopen(path, "wb");
    if (!fp) {
        pthread_rwlock_unlock(&g_exploits.access_lock);
        return -1;
    }
    
    uint32_t magic = EXPLOIT_MAGIC;
    uint32_t version = 2;
    
    fwrite(&magic, sizeof(uint32_t), 1, fp);
    fwrite(&version, sizeof(uint32_t), 1, fp);
    fwrite(&g_exploits.exploit_count, sizeof(int), 1, fp);
    
    for (int i = 0; i < g_exploits.exploit_count; i++) {
        exploit_t *exp = &g_exploits.exploits[i];
        
        /* Write metadata */
        fwrite(&exp->meta, sizeof(exploit_meta_t), 1, fp);
        
        /* Write encrypted data */
        fwrite(exp->encrypted.iv, AES_IV_SIZE, 1, fp);
        fwrite(exp->encrypted.tag, AES_TAG_SIZE, 1, fp);
        fwrite(&exp->encrypted.ciphertext_size, sizeof(size_t), 1, fp);
        
        if (exp->encrypted.ciphertext && exp->encrypted.ciphertext_size > 0) {
            fwrite(exp->encrypted.ciphertext, 1, 
                   exp->encrypted.ciphertext_size, fp);
        }
    }
    
    fclose(fp);
    pthread_rwlock_unlock(&g_exploits.access_lock);
    
    audit_log("SAVE", 0, "Database saved");
    
    return 0;
}

int
exploit_load_all(void)
{
    char path[512];
    snprintf(path, sizeof(path), "%s/exploits.db", g_exploits.storage_path);
    
    FILE *fp = fopen(path, "rb");
    if (!fp) return -1;
    
    uint32_t magic, version;
    fread(&magic, sizeof(uint32_t), 1, fp);
    fread(&version, sizeof(uint32_t), 1, fp);
    
    if (magic != EXPLOIT_MAGIC || version != 2) {
        fclose(fp);
        return -1;
    }
    
    int count;
    fread(&count, sizeof(int), 1, fp);
    
    for (int i = 0; i < count && i < MAX_EXPLOITS; i++) {
        exploit_t *exp = &g_exploits.exploits[i];
        
        fread(&exp->meta, sizeof(exploit_meta_t), 1, fp);
        
        fread(exp->encrypted.iv, AES_IV_SIZE, 1, fp);
        fread(exp->encrypted.tag, AES_TAG_SIZE, 1, fp);
        fread(&exp->encrypted.ciphertext_size, sizeof(size_t), 1, fp);
        
        if (exp->encrypted.ciphertext_size > 0 &&
            exp->encrypted.ciphertext_size <= MAX_EXPLOIT_SIZE) {
            exp->encrypted.ciphertext = malloc(exp->encrypted.ciphertext_size);
            if (exp->encrypted.ciphertext) {
                fread(exp->encrypted.ciphertext, 1,
                      exp->encrypted.ciphertext_size, fp);
            }
        }
        
        g_exploits.exploit_count++;
    }
    
    fclose(fp);
    
    audit_log("LOAD", 0, "Database loaded");
    printf("EXPLOIT: Loaded %d exploits\n", g_exploits.exploit_count);
    
    return 0;
}

/* ==================== Search & List ==================== */

int
exploit_find_for_target(target_platform_t platform, 
                        uint32_t *exploit_ids, int max_count)
{
    int found = 0;
    
    pthread_rwlock_unlock(&g_exploits.access_lock);
    
    for (int i = 0; i < g_exploits.exploit_count && found < max_count; i++) {
        exploit_t *exp = &g_exploits.exploits[i];
        
        if (!exp->meta.enabled)
            continue;
        
        if (exp->meta.platform == platform || exp->meta.platform == PLATFORM_ANY) {
            exploit_ids[found++] = exp->meta.exploit_id;
        }
    }
    
    pthread_rwlock_unlock(&g_exploits.access_lock);
    
    return found;
}

void
exploit_list(void)
{
    printf("\n=== EXPLOIT ARSENAL ===\n");
    
    pthread_rwlock_unlock(&g_exploits.access_lock);
    
    for (int i = 0; i < g_exploits.exploit_count; i++) {
        exploit_meta_t *meta = &g_exploits.exploits[i].meta;
        
        const char *cat_str;
        switch (meta->category) {
        case EXPLOIT_CAT_RECON:   cat_str = "RECON"; break;
        case EXPLOIT_CAT_ACCESS:  cat_str = "ACCESS"; break;
        case EXPLOIT_CAT_PRIVESC: cat_str = "PRIVESC"; break;
        case EXPLOIT_CAT_LATERAL: cat_str = "LATERAL"; break;
        case EXPLOIT_CAT_EXFIL:   cat_str = "EXFIL"; break;
        case EXPLOIT_CAT_PERSIST: cat_str = "PERSIST"; break;
        default:                  cat_str = "UNKNOWN";
        }
        
        printf("[%u] %s (%s) - %s - risk=%d uses=%lu/%lu enc=%zu %s\n",
               meta->exploit_id,
               meta->name,
               meta->cve[0] ? meta->cve : "N/A",
               cat_str,
               meta->risk_level,
               meta->success_count,
               meta->use_count,
               meta->encrypted_size,
               meta->enabled ? "" : "[DISABLED]"
        );
    }
    
    pthread_rwlock_unlock(&g_exploits.access_lock);
    
    printf("\nTotal: %d exploits, uses: %lu, auth_failures: %lu\n",
           g_exploits.exploit_count,
           g_exploits.total_uses,
           g_exploits.auth_failures);
    printf("=======================\n\n");
}
