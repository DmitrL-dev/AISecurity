/*
 * SENTINEL IMMUNE â€” Configuration Parser
 * 
 * INI-style configuration file parser.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#include "../include/hive.h"

#define MAX_CONFIG_ENTRIES  100
#define MAX_KEY_LEN         64
#define MAX_VALUE_LEN       256

/* Config entry */
typedef struct {
    char key[MAX_KEY_LEN];
    char value[MAX_VALUE_LEN];
} config_entry_t;

/* Config context */
typedef struct {
    config_entry_t  entries[MAX_CONFIG_ENTRIES];
    int             entry_count;
    char            path[256];
} config_ctx_t;

/* Global config */
static config_ctx_t g_config;

/* ==================== Helpers ==================== */

static char*
trim(char *str)
{
    while (isspace((unsigned char)*str)) str++;
    
    if (*str == 0) return str;
    
    char *end = str + strlen(str) - 1;
    while (end > str && isspace((unsigned char)*end)) end--;
    
    end[1] = '\0';
    return str;
}

/* ==================== Parser ==================== */

int
config_load(const char *path)
{
    memset(&g_config, 0, sizeof(config_ctx_t));
    
    if (path) {
        strncpy(g_config.path, path, sizeof(g_config.path) - 1);
    }
    
    FILE *fp = fopen(path, "r");
    if (!fp) {
        printf("CONFIG: Cannot open %s\n", path);
        return -1;
    }
    
    char line[512];
    
    while (fgets(line, sizeof(line), fp)) {
        /* Skip comments and empty lines */
        char *p = trim(line);
        
        if (*p == '#' || *p == ';' || *p == '\0')
            continue;
        
        /* Parse key value */
        char *space = strchr(p, ' ');
        if (!space) continue;
        
        *space = '\0';
        
        if (g_config.entry_count >= MAX_CONFIG_ENTRIES)
            break;
        
        config_entry_t *entry = &g_config.entries[g_config.entry_count];
        
        strncpy(entry->key, p, MAX_KEY_LEN - 1);
        strncpy(entry->value, trim(space + 1), MAX_VALUE_LEN - 1);
        
        g_config.entry_count++;
    }
    
    fclose(fp);
    
    printf("CONFIG: Loaded %d entries from %s\n", 
           g_config.entry_count, path);
    
    return 0;
}

int
config_save(const char *path)
{
    const char *save_path = path ? path : g_config.path;
    
    FILE *fp = fopen(save_path, "w");
    if (!fp) return -1;
    
    fprintf(fp, "# SENTINEL IMMUNE Configuration\n");
    fprintf(fp, "# Generated by Hive\n\n");
    
    for (int i = 0; i < g_config.entry_count; i++) {
        fprintf(fp, "%s %s\n", 
                g_config.entries[i].key,
                g_config.entries[i].value);
    }
    
    fclose(fp);
    return 0;
}

/* ==================== Getters ==================== */

const char*
config_get(const char *key)
{
    for (int i = 0; i < g_config.entry_count; i++) {
        if (strcmp(g_config.entries[i].key, key) == 0) {
            return g_config.entries[i].value;
        }
    }
    return NULL;
}

const char*
config_get_default(const char *key, const char *def)
{
    const char *val = config_get(key);
    return val ? val : def;
}

int
config_get_int(const char *key, int def)
{
    const char *val = config_get(key);
    return val ? atoi(val) : def;
}

int
config_get_bool(const char *key, int def)
{
    const char *val = config_get(key);
    if (!val) return def;
    
    if (strcmp(val, "1") == 0 ||
        strcmp(val, "true") == 0 ||
        strcmp(val, "yes") == 0 ||
        strcmp(val, "on") == 0) {
        return 1;
    }
    
    return 0;
}

/* ==================== Setters ==================== */

int
config_set(const char *key, const char *value)
{
    /* Update existing */
    for (int i = 0; i < g_config.entry_count; i++) {
        if (strcmp(g_config.entries[i].key, key) == 0) {
            strncpy(g_config.entries[i].value, value, MAX_VALUE_LEN - 1);
            return 0;
        }
    }
    
    /* Add new */
    if (g_config.entry_count >= MAX_CONFIG_ENTRIES)
        return -1;
    
    config_entry_t *entry = &g_config.entries[g_config.entry_count];
    strncpy(entry->key, key, MAX_KEY_LEN - 1);
    strncpy(entry->value, value, MAX_VALUE_LEN - 1);
    g_config.entry_count++;
    
    return 0;
}

int
config_set_int(const char *key, int value)
{
    char buf[32];
    snprintf(buf, sizeof(buf), "%d", value);
    return config_set(key, buf);
}

/* ==================== Apply to Hive ==================== */

void
config_apply_to_hive(immune_hive_t *hive)
{
    if (!hive) return;
    
    hive->api_port = config_get_int("api_port", 9999);
    hive->agent_port = config_get_int("agent_port", 9998);
    
    const char *data_dir = config_get("data_dir");
    if (data_dir) {
        strncpy(hive->data_path, data_dir, sizeof(hive->data_path) - 1);
    }
    
    printf("CONFIG: Applied to Hive (api=%d, agent=%d)\n",
           hive->api_port, hive->agent_port);
}

/* Debug: print all entries */
void
config_dump(void)
{
    printf("\n=== CONFIGURATION ===\n");
    
    for (int i = 0; i < g_config.entry_count; i++) {
        printf("  %s = %s\n", 
               g_config.entries[i].key,
               g_config.entries[i].value);
    }
    
    printf("=====================\n\n");
}
